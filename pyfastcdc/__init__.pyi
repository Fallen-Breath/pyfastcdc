from pathlib import Path
from typing import Optional, Union, Iterator

from typing_extensions import Protocol, Literal

__version__: str


class _BinaryStreamReaderWithRead(Protocol):
	def read(self, n: int) -> bytes: ...


class _BinaryStreamReaderWithReadinto(Protocol):
	def readinto(self, b: memoryview) -> int: ...


BinaryStreamReader = Union[_BinaryStreamReaderWithRead, _BinaryStreamReaderWithReadinto]
"""
A reader object that supports ``read()`` or ``readinto()`` methods.
``readinto()`` is preferred since it's faster than ``read()``
"""

NormalizedChunking = Literal[0, 1, 2, 3]
"""
The normalized chunking parameter (NC) from the paper
"""


class FastCDC:
	"""
	The FastCDC 2020 chunker implementation

	Paper: https://ieeexplore.ieee.org/document/9055082
	"""

	def __init__(
			self,
			avg_size: int = 16384,
			*,
			min_size: Optional[int] = None,
			max_size: Optional[int] = None,
			normalized_chunking: NormalizedChunking = 1,
			seed: int = 0,
	):
		"""
		Construct a FastCDC instance for chunking. The instance can be reused for multiple chunking operations

		:param avg_size: Specifies the average output chunk size. Suggested to be a power of 2.
			Note: The actual output average chunk size is ``avg_size + min_size``,
			as described in the paper section 3.4 "Cut-Point Skipping".
			Default is 16384, should be within [256, 4194304]
		:keyword min_size: Specifies the minimum constraint for the output chunk size.
			Default is None, meaning ``avg_size // 4``. The value should be within [64, 1048576]
		:keyword max_size: Specifies the maximum constraint for the output chunk size.
			Default is None, meaning ``avg_size * 4``. The value should be within [1024, 16777216]
		:keyword normalized_chunking: Defines the normalized chunking parameter (NC) from the paper.
			Increasing the value will decrease the number of too-small / too-big chunks
			and might also decrease the deduplication ratio if NC is set to too high.
			The default NC value is 1, aligning with https://github.com/nlfiedler/fastcdc-rs.
			See the paper for more details:
			1. Section 3.5 "Normalized Chunking" on how NC works
			2. Section 4.4 "Evaluation of Normalized Chunking" on evaluation results for different NC values
		:keyword seed: Provides an optional seed value to alternate the gear table.
			Default is 0, meaning using the default gear table from the C reference repository from the paper
			(https://github.com/HIT-HSSL/destor/blob/master/src/chunking/fascdc_chunking.c)
			will be used
		"""
		...

	def cut_buf(self, buf: Union[bytes, bytearray, memoryview]) -> Iterator[Chunk]:
		"""
		Cut the given buffer with FastCDC algorithm

		:param buf: The input buffer to be processed
		:return: An iterator that yields ``Chunk`` objects
		"""
		...

	def cut_file(self, file_path: Union[str, bytes, Path]) -> Iterator[Chunk]:
		"""
		Cut the given file with FastCDC algorithm

		:param file_path: Path to the file to be processed. It should be a readable regular file
		:return: An iterator that yields ``Chunk`` objects
		"""
		...

	def cut_stream(self, stream: BinaryStreamReader) -> Iterator[Chunk]:
		"""
		Cut the given stream with FastCDC algorithm

		.. caution::

			All chunks generated by this method have their `.data` fields guaranteed to be valid before and only before the next chunk is generated

		:param stream: The input stream to be processed. It needs to have any of the following methods:

		* ``read(self, n: int) -> bytes``
		* ``readinto(self, b: memoryview) -> int``  (preferred)

		:return: An iterator that yields ``Chunk`` objects
		"""
		...

	@property
	def avg_size(self) -> int:
		...

	@property
	def min_size(self) -> int:
		...

	@property
	def max_size(self) -> int:
		...


class Chunk:
	"""
	Represents a chunk of data generated by FastCDC algorithm
	"""

	offset: int
	"""
	The offset of the chunk in bytes from the beginning of the input
	"""

	length: int
	"""
	The length of the chunk in bytes. The same as ``len(data)``
	"""

	data: memoryview
	"""
	Memory view of the chunk data

	.. caution::

		For chunks generated from ``cut_stream()``, this memory view is only guaranteed to be valid before the next chunk is generated

	.. note::

		For chunks generated from ``cut_files()``, this memory view will be pointed to part of an mmap object of the input file,
		which means the mmap object won't be released until all references to the generated chunk objects are released
	"""

	gear_hash: int
	"""
	FastCDC's gear hash for this chunk, range within uint64

	You should not use this hash for actual data deduplication since it's not guaranteed to be high quality
	"""

	def __init__(self, offset: int, length: int, data: memoryview, gear_hash: int):
		...
